# play-leetcode
- [x] 1343 大小为 K 且平均数大于等于阈值的子数组个数</br>
  ps：排序找到最开始超过阈值的下标进行计算。❌：子数组是在原有数组基础上进行的查找
- [x] 1144 递减元素使数组呈锯齿状</br>
   解题思路：指针下标step为2，依次指向峰值位置 -> 判断是否小于等于左边数值（考虑下标>0）如满足，则计算差值 且 + 1 -> 同理判断是否小于等于右边数值(考虑不为最后一位) -> 取奇偶锯齿状最短操作数
- [x] 473 火柴拼正方形</br>
    -排除常规不可能 1.边数少于4 2. 总长度不能被 4 整除
    - ❌：原始思路错误点：双指针，求和为平均数。忽略[3,3,3,3,4,4,4,4,5,5,5,5]这种边长为 12 由两条以上边组成情况
    - 解决思路：**回溯** 创建 4 个桶。
        - 结束条件：所有边被访问完。
        - 进桶条件：当前+桶内 < target(目标边长)
        - 不满足：则回退当前桶值 
- [x] 206 反转链表</br>
    - 操作 3 个指针，分别 pre、cur、next
        - next = cur->next;
        - cur->next = pre
        - pre = cur;
        - cur = next;
- [x] 92 反转链表II</br>
    - 解题思路：1. 分段操作 中间段进行反转 2. 链表拼接 
        - pre = null;
        - cur、next = head;
        - 前段拷贝：
            pre = cur;
            cur = cur->next;
        - 中段反转
            ⚠️ 反转前记录 pre 和 cur 的位置 【作为中段链表的头、尾、届时进行链表拼接】
            - pre2 = pre; cur2 = cur;
            - 开始经典反转 4 步骤
                - next = cur->next;
                - cur->next = pre;
                - pre = cur;
                - cur = next;
        - 链表拼接
            - head 始终为该链表的头部
            - pre2->next = pre;
            - cur2->next = cur;
- [x] 83 删除有序链表中重复元素</br>
    - 解题思路：遍历链表，设置两个链表指针 cur、next 
        - 如果 cur->val == next->val 则删除当前next指针。删除方式：cur->next = next->next。⚠️切勿进行 cur = cur->next的操作。否则将变成两两比较 测试用例：[1,1,1,1]
        - 如果 cur->val != next->val 则cur进入下一步 cur = cur->next
        - ⚠️注意判断：cur 以及 cur->next 为 null 的情况，作为循环终止条件
    - 错误思路：1.设置虚拟头指针 导致起始位置比较的时候，创建数值可能会等于head真正的第一个元素

- [x] 445 两数相加II</br>
    - ❌ 1. 获取第一个链表的和 2. 获取第二个链表的总和 3. 将两和相加结果倒入结果链表。
        - 错误原因：求和一定要注意内存占用长度会不会比分配的类型大
    - 解题思路：
        - 1. 第一个链表数据存入栈中
        - 2. 第二个链表数据存入栈中
        - 3. 依次从两个链表中获取数据 将求和结果倒入结果链表 
            - ⚠️ a. 链表是否为空
            - ⚠️ b. 是否需要进位
            - ⚠️ c. 注意 [5] [5] 情况下链表结果
    - 倒入链表
        - node = new ListNode(x);
        - node->next = p;
        - p = node;

- [x] 82 删除排序链表中重复元素II</br>
    - 解题思路：
        - 1. 设置三个指针，分别是 pre、cur、next。
        - 2. 遍历链表，如果遇到重复的元素，则： 
            - cur->next = next->next;
            - ⚠️按题意来说出现重复 cur 也应该要删除
        - 3. 设置一个flag判断 cur 是否为删除后留下的唯一元素。
            - 如果 cur 是待删除的唯一元素则：pre = cur->next; (跳过对cur当前的指针连接)
            - 如果 cur 不是待删除指针：pre = cur; 
            - cur = next;
        - ❌：善后：当 cur 和 next 为空的时候，flag 为 true 说明最后一个元素的 cur 仍然需要绕过：pre->next = null;
- [x] 1528 重新排列字符串</b
    - 提升的解题思路：字符数组，下标为【indices[i]】 内容为【s.charAt()[i]】
    - 我一开始使用：map<key,value>存一遍、取一遍 
